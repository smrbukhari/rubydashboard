quit
quit()
quit
document
c
document
c
document
c
document
c
document
quit
key
c
key
quit
document
c
document
c
document
c
document
c
document
c
document
quit
c
counter
client[static_collection].find().each do |d| counter += 1 end
counter = 0
quit
quit()
document
c
document
document[rr]
c
document[rr]
quit
quit()
c
counter
c
counter
c
value
c
value
c
value
c
value
quit
document['productname'] 
c
document['productname'] 
document
quit
key
c
key
c
key
ss
row_val
row_data
col_val
c
row_val
sorted_date
sort_date
row_val
c
sorted_date
unsorted_date
quit
c
parsed_date.to_date
a = Date.parse(date_val)
a = Date.parse(parsed_date)
date_val
parsed_date
c
client[qq].find().each do |document| doc_arr = [] r = document[ss] puts(r) end
client[qq].find().each do |document| doc_arr = [] r = document[ss] col_data << r end
c
r = document[ss]
r
ss
qq
rr
c
client[qq].find().each do |document|  end
client[qq]
rr
ss
qq
c
quit
collection_docs
c
collection_docs
c
collection_docs
c
collection_docs
quit
c
indexing(row,columns)
instance
c
client[collectionname].find().each do |document| client[collectionname].insert_one(:uploaded_at => Time.now.strftime("%e/%b/%Y %H:%M:%S %z")) end
client[collectionname].find().each do |document| client[collectionname].insert_one({:uploaded_at => Time.now.strftime("%e/%b/%Y %H:%M:%S %z")}) end
client[collectionname].find().each do |document|
c
ss[0][6]
ss[0][4]
ss[0][0]
ss[00]
ss[0]
ss[2]
ss[3]
ss[4]
ss[5]
rr
ss
ss.last
ss
zz
c
ss
c
ss
exit
key
exit
c
third_value
second_value
first_value
third_value
params["mathoperator"]
exit
params["mathoperator"]
operatorused
exit
c
operatorused
first_value + second_value
third_value
second_value
first_value
q
c
test
document.each do |key,value| test << value  end
document.each do |key,value| end
document.each do |key,value|
test = []
document
c
ss
c
ss
c
ss[0][0]
ss
c
ss[1]
ss[0]
ss[]
ss.first
ss
ss << recursive_keys_final(rr)
rr = JSON.parse(rr)
rr = collection_doc.first.to_json
c
rr = JSON.parse(rr)
rr = collection_doc.first.to_json
collection_doc.first
collection_doc.id
collection_doc._id
rr = collection_doc.as_json(:except => :_id).merge('_id' => collection_doc.id).to_json
collection_doc
rr
ss
c
cfv.first
cfv[0]
cfv
client[qq].find().each do |document| cfv << document end
cfv
cfv=[]
bb
client[qq].find().each do |document| bb=document end
b
client[qq].find().each do |document| b=document end
client[qq].first
client[qq][0]
client[qq].find().each
client[qq].each
client[qq]
c
column_first
c
column_first[0].split
column_first
c
column_first
c
q
columns = columnsfirst[0].split
columns = columnsfirst.split
columnsfirst = row.collect { |c| c.downcase.gsub(' ', '_') }
split_col = columns[0].split
columns = row.collect { |c| c.downcase.gsub(' ', '_') }
c
split_col = columns[0].split
columns = row.collect { |c| c.downcase.gsub(' ', '_') }
q
test[0].split
test[0]
test = ["id\tdate_time\tcpu_util\tcpu_idle\tcpu_top\tmem_usage"]
row
columns = row.collect { |c| c.downcase.gsub(' ', '_') }
q
columns = row.collect { |c| c.downcase.gsub(" ", "\t") }
columns = row.collect { |c| c.downcase.gsub("\t", '_') }
columns
columns = row.collect { |c| c.downcase.gsub(' ', '_') }
row.collect
columns
q
columns.first
columns[0]
columns(0)
columns
columns = row.collect { |c| c.downcase.gsub(' ', '_') }
row.collect
row
q
row
q
filedata
q
filedata
q
filedata.content_type
filedata
c
item
c
item
