c
@collection_docs.first
c
@collection_docs.first["vendor_with_polygons"].first["Vendor"]
@collection_docs.first["vendor_with_polygons"]["Vendor"]
@collection_docs.first["vendor_with_polygons"]
@collection_docs.first["vendor_with_polygons"]["Vendor"]
@collection_docs.first
@collection_docs.first["state"]
@collection_docs.first["state"]["Vendor"]
@collection_docs.first["Vendor"]
@collection_docs.first[Vendor]
@collection_docs.first.Vendor
@collection_docs.each do |document|
@collection_docs.first
@collection_docs
collection_docs
c
params["Region"]
params[:filter1_option]
params[:filter3]
{params[:filter3]}
$#{params[:filter3]}
params[:filter2gfhj]
params[:filter2_suboptions]
params[:filter2]
params[:filter]
params[:filter1]
params[filter1]
c
result
c
result.first
c
result.first
c
testmap
all_tweet
applicant
tweet.first
tweet[0]
tweet
c
e
c
label_data.each do |item|
result_data = []
result_hash = {}
label_data
c
collection_names
n
collection_names
next
n
collection_names
c
collection_names
first_doc["biuser_id"] == current_user.id
current_user.id
quit
quit()
quit
document
c
document
c
document
c
document
c
document
quit
key
c
key
quit
document
c
document
c
document
c
document
c
document
c
document
quit
c
counter
client[static_collection].find().each do |d| counter += 1 end
counter = 0
quit
quit()
document
c
document
document[rr]
c
document[rr]
quit
quit()
c
counter
c
counter
c
value
c
value
c
value
c
value
quit
document['productname'] 
c
document['productname'] 
document
quit
key
c
key
c
key
ss
row_val
row_data
col_val
c
row_val
sorted_date
sort_date
row_val
c
sorted_date
unsorted_date
quit
c
parsed_date.to_date
a = Date.parse(date_val)
a = Date.parse(parsed_date)
date_val
parsed_date
c
client[qq].find().each do |document| doc_arr = [] r = document[ss] puts(r) end
client[qq].find().each do |document| doc_arr = [] r = document[ss] col_data << r end
c
r = document[ss]
r
ss
qq
rr
c
client[qq].find().each do |document|  end
client[qq]
rr
ss
qq
c
quit
collection_docs
c
collection_docs
c
collection_docs
c
collection_docs
quit
c
indexing(row,columns)
instance
c
client[collectionname].find().each do |document| client[collectionname].insert_one(:uploaded_at => Time.now.strftime("%e/%b/%Y %H:%M:%S %z")) end
client[collectionname].find().each do |document| client[collectionname].insert_one({:uploaded_at => Time.now.strftime("%e/%b/%Y %H:%M:%S %z")}) end
client[collectionname].find().each do |document|
c
ss[0][6]
ss[0][4]
ss[0][0]
ss[00]
ss[0]
ss[2]
ss[3]
ss[4]
ss[5]
rr
ss
ss.last
ss
zz
c
ss
c
ss
exit
key
exit
c
third_value
second_value
first_value
third_value
params["mathoperator"]
exit
params["mathoperator"]
operatorused
exit
c
operatorused
first_value + second_value
third_value
second_value
first_value
q
c
test
document.each do |key,value| test << value  end
document.each do |key,value| end
document.each do |key,value|
test = []
document
c
ss
c
ss
c
ss[0][0]
ss
c
ss[1]
ss[0]
ss[]
ss.first
ss
ss << recursive_keys_final(rr)
rr = JSON.parse(rr)
rr = collection_doc.first.to_json
c
rr = JSON.parse(rr)
rr = collection_doc.first.to_json
collection_doc.first
collection_doc.id
collection_doc._id
rr = collection_doc.as_json(:except => :_id).merge('_id' => collection_doc.id).to_json
collection_doc
rr
ss
c
cfv.first
cfv[0]
cfv
client[qq].find().each do |document| cfv << document end
cfv
cfv=[]
